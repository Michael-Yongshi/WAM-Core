PragmaDirective
   Source: "pragma solidity ^0.5.10;"
ImportDirective "./openzeppelin-contracts-2.5.0/contracts/token/ERC721/IERC721.sol"
   Source: "import \"./openzeppelin-contracts-2.5.0/contracts/token/ERC721/IERC721.sol\";"
ImportDirective "./openzeppelin-contracts-2.5.0/contracts/token/ERC721/IERC721Receiver.sol"
   Source: "import \"./openzeppelin-contracts-2.5.0/contracts/token/ERC721/IERC721Receiver.sol\";"
ImportDirective "./openzeppelin-contracts-2.5.0/contracts/introspection/ERC165.sol"
   Source: "import \"./openzeppelin-contracts-2.5.0/contracts/introspection/ERC165.sol\";"
ImportDirective "./openzeppelin-contracts-2.5.0/contracts/math/SafeMath.sol"
   Source: "import \"./openzeppelin-contracts-2.5.0/contracts/math/SafeMath.sol\";"
ContractDefinition "CryptoCharacter"
   Source: "contract CryptoCharacter is IERC721, ERC165 {\r\n\r\n    // Use Open Zeppelin's SafeMath library to perform arithmetic operations safely.\r\n    using SafeMath for uint256;\r\n\r\n    /*\r\n        A Character has only 5 parts that can change according to its DNA.\r\n        When we generate DNA, we get a 10 digit long number, and each pair corresponds to a specific ingredient.\r\n\r\n        E.g. DNA 5142446803 - 51_Basis/42_Cheeses/44_Meats/68_Spices/03_Vegetables\r\n    */\r\n    uint constant dnaDigits = 10;\r\n    uint constant dnaModulus = 10 ** dnaDigits;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    struct Character {\r\n        string identifier;\r\n        string name;\r\n        string unit;\r\n        string race;\r\n        uint dna;\r\n    }\r\n\r\n    Character[] public characters;\r\n\r\n    struct Event {\r\n        string description;\r\n    }\r\n\r\n    Event[] public events;\r\n    // string[] public events;\r\n\r\n    // Mapping from owner to id of Character\r\n    mapping (uint => address) public characterToOwner;\r\n\r\n    // Mapping from id of Character to id of Event\r\n    mapping (uint => uint) public eventToCharacter;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => uint) public ownerCharacterCount;\r\n\r\n    // Mapping from character to number of owned events\r\n    mapping (uint => uint) public characterEventCount;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint => address) characterApprovals;\r\n// Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) private operatorApprovals;\r\n\r\n    // Create random Character from string (name) and DNA\r\n    function _createCharacter(\r\n        string memory _identifier,\r\n        string memory _name,\r\n        string memory _unit,\r\n        string memory _race,\r\n        uint _dna\r\n        )\r\n        internal\r\n        isUnique(_identifier, _dna)\r\n    {\r\n        // Add Character to array and get id\r\n        uint id = SafeMath.sub(\r\n            characters.push(\r\n                Character(\r\n                    _identifier,\r\n                    _name,\r\n                    _unit,\r\n                    _race,\r\n                    _dna\r\n                    )\r\n                ),\r\n            1);\r\n        // Map owner to id of Character\r\n        assert(characterToOwner[id] == address(0));\r\n        characterToOwner[id] = msg.sender;\r\n        ownerCharacterCount[msg.sender] = SafeMath.add(ownerCharacterCount[msg.sender], 1);\r\n    \r\n        // Add creation event to character\r\n        // string memory comment = \"Character Created\";\r\n        // createEvent(\r\n        //     id,\r\n        //     comment\r\n        //     );\r\n    }\r\n\r\n    // Create Event from string\r\n    function createEvent(\r\n        uint _characterId,\r\n        string memory _description\r\n        )\r\n        public\r\n    {\r\n        // Add event to array and get id\r\n        uint id = SafeMath.sub(\r\n            events.push(\r\n                Event(\r\n                    _description\r\n                    )\r\n                ),\r\n            1);\r\n\r\n        // Map id of Character to id of Event\r\n        assert(eventToCharacter[id] == uint(0));\r\n        eventToCharacter[id] = _characterId;\r\n        characterEventCount[_characterId] = SafeMath.add(characterEventCount[_characterId], 1);\r\n    }\r\n\r\n    // Creates random Character from string (identifier)\r\n    function createRandomCharacter(\r\n        string memory _identifier,\r\n        string memory _name,\r\n        string memory _unit,\r\n        string memory _race\r\n        )\r\n        public\r\n    {\r\n        uint randDna = generateRandomDna(_identifier, msg.sender);\r\n        _createCharacter(\r\n            _identifier,\r\n            _name,\r\n            _unit,\r\n            _race,\r\n            randDna\r\n            );\r\n    }\r\n\r\n    // Generate random DNA from string (identifier) and address of the owner (creator)\r\n    function generateRandomDna(string memory _str, address _owner)\r\n        public\r\n        pure\r\n        returns(uint)\r\n    {\r\n        // Generate random uint from string (identifier) + address (owner)\r\n        uint rand = uint(keccak256(abi.encodePacked(_str))) + uint(_owner);\r\n        rand = rand % dnaModulus;\r\n        return rand;\r\n    }\r\n\r\n    // Returns array of Characters found by owner\r\n    function getCharactersByOwner(address _owner)\r\n        public\r\n        view\r\n        returns(uint[] memory)\r\n    {\r\n        uint[] memory result = new uint[](ownerCharacterCount[_owner]);\r\n        uint counter = 0;\r\n        for (uint i = 0; i < characters.length; i++) {\r\n            if (characterToOwner[i] == _owner) {\r\n                result[counter] = i;\r\n                counter++;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // Returns array of Events found by characterId\r\n    function getEventsByCharacter(uint _characterId)\r\n        public\r\n        view\r\n        returns(uint[] memory)\r\n    {\r\n        uint[] memory result = new uint[](characterEventCount[_characterId]);\r\n        uint counter = 0;\r\n        for (uint i = 0; i < events.length; i++) {\r\n            result[counter] = i;\r\n            counter++;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // Transfer Character to other wallet (internal function)\r\n    function transferFrom(address _from, address _to, uint256 _characterId)\r\n        public\r\n    {\r\n        require(_from != address(0) && _to != address(0));\r\n        require(_exists(_characterId));\r\n        require(_from != _to);\r\n        require(_isApprovedOrOwner(msg.sender, _characterId));\r\n        ownerCharacterCount[_to] = SafeMath.add(ownerCharacterCount[_to], 1);\r\n        ownerCharacterCount[_from] = SafeMath.sub(ownerCharacterCount[_from], 1);\r\n        characterToOwner[_characterId] = _to;\r\n        emit Transfer(_from, _to, _characterId);\r\n        _clearApproval(_to, _characterId);\r\n    }\r\n\r\n    /**\r\n     * Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n    */\r\n    function safeTransferFrom(address from, address to, uint256 characterId)\r\n        public\r\n    {\r\n        // solium-disable-next-line arg-overflow\r\n        this.safeTransferFrom(from, to, characterId, \"\");\r\n    }\r\n\r\n    /**\r\n     * Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 characterId, bytes memory _data)\r\n        public\r\n    {\r\n        this.transferFrom(from, to, characterId);\r\n        // solium-disable-next-line arg-overflow\r\n        require(_checkOnERC721Received(from, to, characterId, _data));\r\n    }\r\n\r\n    /**\r\n     * Internal function to invoke `onERC721Received` on a target address\r\n     * The call is not executed if the target address is not a contract\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 characterId, bytes memory _data)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        if (!isContract(to)) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, characterId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    // Burn Character - destroys Token completely\r\n    function burn(uint256 _characterId)\r\n        external\r\n    {\r\n        require(msg.sender != address(0));\r\n        require(_exists(_characterId));\r\n        require(_isApprovedOrOwner(msg.sender, _characterId));\r\n\r\n        ownerCharacterCount[msg.sender] = SafeMath.sub(ownerCharacterCount[msg.sender], 1);\r\n        characterToOwner[_characterId] = address(0);\r\n    }\r\n\r\n    // Returns count of Characters by address\r\n    function balanceOf(address _owner)\r\n        public\r\n        view\r\n        returns(uint256 _balance)\r\n    {\r\n        return ownerCharacterCount[_owner];\r\n    }\r\n\r\n    // Returns owner of the Character found by id\r\n    function ownerOf(uint256 _characterId)\r\n        public\r\n        view\r\n        returns(address _owner)\r\n    {\r\n        address owner = characterToOwner[_characterId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    // Approve other wallet to transfer ownership of Character\r\n    function approve(address _to, uint256 _characterId)\r\n        public\r\n    {\r\n        require(msg.sender == characterToOwner[_characterId]);\r\n        characterApprovals[_characterId] = _to;\r\n        emit Approval(msg.sender, _to, _characterId);\r\n    }\r\n\r\n    // Return approved address for specific Character\r\n    function getApproved(uint256 characterId)\r\n        public\r\n        view\r\n        returns(address operator)\r\n    {\r\n        require(_exists(characterId));\r\n        return characterApprovals[characterId];\r\n    }\r\n\r\n    /**\r\n     * Private function to clear current approval of a given token ID\r\n     * Reverts if the given address is not indeed the owner of the token\r\n     */\r\n    function _clearApproval(address owner, uint256 characterId) private {\r\n        require(characterToOwner[characterId] == owner);\r\n        require(_exists(characterId));\r\n        if (characterApprovals[characterId] != address(0)) {\r\n            characterApprovals[characterId] = address(0);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Sets or unsets the approval of a given operator\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf\r\n     */\r\n    function setApprovalForAll(address to, bool approved)\r\n        public\r\n    {\r\n        require(to != msg.sender);\r\n        operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    // Tells whether an operator is approved by a given owner\r\n    function isApprovedForAll(address owner, address operator)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return operatorApprovals[owner][operator];\r\n    }\r\n\r\n    // Take ownership of Character - only for approved users\r\n    function takeOwnership(uint256 _characterId)\r\n        public\r\n    {\r\n        require(_isApprovedOrOwner(msg.sender, _characterId));\r\n        address owner = this.ownerOf(_characterId);\r\n        this.transferFrom(owner, msg.sender, _characterId);\r\n    }\r\n\r\n    // Check if Character exists\r\n    function _exists(uint256 characterId)\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        address owner = characterToOwner[characterId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    function _isApprovedOrOwner(address spender, uint256 characterId)\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        address owner = characterToOwner[characterId];\r\n        // Disable solium check because of\r\n        // https://github.com/duaraghav8/Solium/issues/175\r\n        // solium-disable-next-line operator-whitespace\r\n        return (spender == owner || this.getApproved(characterId) == spender || this.isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    // Check if Character is unique and doesn't exist yet\r\n    modifier isUnique(string memory _identifier, uint256 _dna) {\r\n        bool result = true;\r\n        for(uint i = 0; i < characters.length; i++) {\r\n            if(keccak256(abi.encodePacked(characters[i].identifier)) == keccak256(abi.encodePacked(_identifier)) && characters[i].dna == _dna) {\r\n                result = false;\r\n            }\r\n        }\r\n        require(result, \"Character with name, unit and race combination already exists.\");\r\n        _;\r\n    }\r\n\r\n    // Returns whether the target address is a contract\r\n    function isContract(address account)\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}"
  InheritanceSpecifier
     Source: "IERC721"
    UserDefinedTypeName "IERC721"
       Source: "IERC721"
  InheritanceSpecifier
     Source: "ERC165"
    UserDefinedTypeName "ERC165"
       Source: "ERC165"
  UsingForDirective
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "dnaDigits"
     Type: uint256
     Source: "uint constant dnaDigits = 10"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 10
       Type: int_const 10
       Source: "10"
  VariableDeclaration "dnaModulus"
     Type: uint256
     Source: "uint constant dnaModulus = 10 ** dnaDigits"
    ElementaryTypeName uint
       Source: "uint"
    BinaryOperation using operator **
       Type: uint256
       Source: "10 ** dnaDigits"
      Literal, token: [no token] value: 10
         Type: int_const 10
         Source: "10"
      Identifier dnaDigits
         Type: uint256
         Source: "dnaDigits"
  VariableDeclaration "_ERC721_RECEIVED"
     Type: bytes4
     Source: "bytes4 private constant _ERC721_RECEIVED = 0x150b7a02"
    ElementaryTypeName bytes4
       Source: "bytes4"
    Literal, token: [no token] value: 0x150b7a02
       Type: int_const 353073666
       Source: "0x150b7a02"
  StructDefinition "Character"
     Source: "struct Character {\r\n        string identifier;\r\n        string name;\r\n        string unit;\r\n        string race;\r\n        uint dna;\r\n    }"
    VariableDeclaration "identifier"
       Type: string storage pointer
       Source: "string identifier"
      ElementaryTypeName string
         Source: "string"
    VariableDeclaration "name"
       Type: string storage pointer
       Source: "string name"
      ElementaryTypeName string
         Source: "string"
    VariableDeclaration "unit"
       Type: string storage pointer
       Source: "string unit"
      ElementaryTypeName string
         Source: "string"
    VariableDeclaration "race"
       Type: string storage pointer
       Source: "string race"
      ElementaryTypeName string
         Source: "string"
    VariableDeclaration "dna"
       Type: uint256
       Source: "uint dna"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "characters"
     Type: struct CryptoCharacter.Character storage ref[] storage ref
     Source: "Character[] public characters"
    ArrayTypeName
       Source: "Character[]"
      UserDefinedTypeName "Character"
         Source: "Character"
  StructDefinition "Event"
     Source: "struct Event {\r\n        string description;\r\n    }"
    VariableDeclaration "description"
       Type: string storage pointer
       Source: "string description"
      ElementaryTypeName string
         Source: "string"
  VariableDeclaration "events"
     Type: struct CryptoCharacter.Event storage ref[] storage ref
     Source: "Event[] public events"
    ArrayTypeName
       Source: "Event[]"
      UserDefinedTypeName "Event"
         Source: "Event"
  VariableDeclaration "characterToOwner"
     Type: mapping(uint256 => address)
     Source: "mapping (uint => address) public characterToOwner"
    Mapping
       Source: "mapping (uint => address)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "eventToCharacter"
     Type: mapping(uint256 => uint256)
     Source: "mapping (uint => uint) public eventToCharacter"
    Mapping
       Source: "mapping (uint => uint)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "ownerCharacterCount"
     Type: mapping(address => uint256)
     Source: "mapping (address => uint) public ownerCharacterCount"
    Mapping
       Source: "mapping (address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "characterEventCount"
     Type: mapping(uint256 => uint256)
     Source: "mapping (uint => uint) public characterEventCount"
    Mapping
       Source: "mapping (uint => uint)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "characterApprovals"
     Type: mapping(uint256 => address)
     Source: "mapping (uint => address) characterApprovals"
    Mapping
       Source: "mapping (uint => address)"
      ElementaryTypeName uint
         Source: "uint"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "operatorApprovals"
     Type: mapping(address => mapping(address => bool))
     Source: "mapping (address => mapping (address => bool)) private operatorApprovals"
    Mapping
       Source: "mapping (address => mapping (address => bool))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => bool)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "_createCharacter"
     Source: "function _createCharacter(\r\n        string memory _identifier,\r\n        string memory _name,\r\n        string memory _unit,\r\n        string memory _race,\r\n        uint _dna\r\n        )\r\n        internal\r\n        isUnique(_identifier, _dna)\r\n    {\r\n        // Add Character to array and get id\r\n        uint id = SafeMath.sub(\r\n            characters.push(\r\n                Character(\r\n                    _identifier,\r\n                    _name,\r\n                    _unit,\r\n                    _race,\r\n                    _dna\r\n                    )\r\n                ),\r\n            1);\r\n        // Map owner to id of Character\r\n        assert(characterToOwner[id] == address(0));\r\n        characterToOwner[id] = msg.sender;\r\n        ownerCharacterCount[msg.sender] = SafeMath.add(ownerCharacterCount[msg.sender], 1);\r\n    \r\n        // Add creation event to character\r\n        // string memory comment = \"Character Created\";\r\n        // createEvent(\r\n        //     id,\r\n        //     comment\r\n        //     );\r\n    }"
    ParameterList
       Source: "(\r\n        string memory _identifier,\r\n        string memory _name,\r\n        string memory _unit,\r\n        string memory _race,\r\n        uint _dna\r\n        )"
      VariableDeclaration "_identifier"
         Type: string memory
         Source: "string memory _identifier"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_name"
         Type: string memory
         Source: "string memory _name"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_unit"
         Type: string memory
         Source: "string memory _unit"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_race"
         Type: string memory
         Source: "string memory _race"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_dna"
         Type: uint256
         Source: "uint _dna"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
    ModifierInvocation "isUnique"
       Source: "isUnique(_identifier, _dna)"
      Identifier isUnique
         Type: modifier (string memory,uint256)
         Source: "isUnique"
      Identifier _identifier
         Type: string memory
         Source: "_identifier"
      Identifier _dna
         Type: uint256
         Source: "_dna"
    Block
       Source: "{\r\n        // Add Character to array and get id\r\n        uint id = SafeMath.sub(\r\n            characters.push(\r\n                Character(\r\n                    _identifier,\r\n                    _name,\r\n                    _unit,\r\n                    _race,\r\n                    _dna\r\n                    )\r\n                ),\r\n            1);\r\n        // Map owner to id of Character\r\n        assert(characterToOwner[id] == address(0));\r\n        characterToOwner[id] = msg.sender;\r\n        ownerCharacterCount[msg.sender] = SafeMath.add(ownerCharacterCount[msg.sender], 1);\r\n    \r\n        // Add creation event to character\r\n        // string memory comment = \"Character Created\";\r\n        // createEvent(\r\n        //     id,\r\n        //     comment\r\n        //     );\r\n    }"
      VariableDeclarationStatement
         Source: "uint id = SafeMath.sub(\r\n            characters.push(\r\n                Character(\r\n                    _identifier,\r\n                    _name,\r\n                    _unit,\r\n                    _race,\r\n                    _dna\r\n                    )\r\n                ),\r\n            1)"
        VariableDeclaration "id"
           Type: uint256
           Source: "uint id"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "SafeMath.sub(\r\n            characters.push(\r\n                Character(\r\n                    _identifier,\r\n                    _name,\r\n                    _unit,\r\n                    _race,\r\n                    _dna\r\n                    )\r\n                ),\r\n            1)"
          MemberAccess to member sub
             Type: function (uint256,uint256) pure returns (uint256)
             Source: "SafeMath.sub"
            Identifier SafeMath
               Type: type(library SafeMath)
               Source: "SafeMath"
          FunctionCall
             Type: uint256
             Source: "characters.push(\r\n                Character(\r\n                    _identifier,\r\n                    _name,\r\n                    _unit,\r\n                    _race,\r\n                    _dna\r\n                    )\r\n                )"
            MemberAccess to member push
               Type: function (struct CryptoCharacter.Character storage ref) returns (uint256)
               Source: "characters.push"
              Identifier characters
                 Type: struct CryptoCharacter.Character storage ref[] storage ref
                 Source: "characters"
            FunctionCall
               Type: struct CryptoCharacter.Character memory
               Source: "Character(\r\n                    _identifier,\r\n                    _name,\r\n                    _unit,\r\n                    _race,\r\n                    _dna\r\n                    )"
              Identifier Character
                 Type: type(struct CryptoCharacter.Character storage pointer)
                 Source: "Character"
              Identifier _identifier
                 Type: string memory
                 Source: "_identifier"
              Identifier _name
                 Type: string memory
                 Source: "_name"
              Identifier _unit
                 Type: string memory
                 Source: "_unit"
              Identifier _race
                 Type: string memory
                 Source: "_race"
              Identifier _dna
                 Type: uint256
                 Source: "_dna"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ExpressionStatement
         Source: "assert(characterToOwner[id] == address(0))"
        FunctionCall
           Type: tuple()
           Source: "assert(characterToOwner[id] == address(0))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "characterToOwner[id] == address(0)"
            IndexAccess
               Type: address
               Source: "characterToOwner[id]"
              Identifier characterToOwner
                 Type: mapping(uint256 => address)
                 Source: "characterToOwner"
              Identifier id
                 Type: uint256
                 Source: "id"
            FunctionCall
               Type: address payable
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Source: "characterToOwner[id] = msg.sender"
        Assignment using operator =
           Type: address
           Source: "characterToOwner[id] = msg.sender"
          IndexAccess
             Type: address
             Source: "characterToOwner[id]"
            Identifier characterToOwner
               Type: mapping(uint256 => address)
               Source: "characterToOwner"
            Identifier id
               Type: uint256
               Source: "id"
          MemberAccess to member sender
             Type: address payable
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Source: "ownerCharacterCount[msg.sender] = SafeMath.add(ownerCharacterCount[msg.sender], 1)"
        Assignment using operator =
           Type: uint256
           Source: "ownerCharacterCount[msg.sender] = SafeMath.add(ownerCharacterCount[msg.sender], 1)"
          IndexAccess
             Type: uint256
             Source: "ownerCharacterCount[msg.sender]"
            Identifier ownerCharacterCount
               Type: mapping(address => uint256)
               Source: "ownerCharacterCount"
            MemberAccess to member sender
               Type: address payable
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "SafeMath.add(ownerCharacterCount[msg.sender], 1)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "SafeMath.add"
              Identifier SafeMath
                 Type: type(library SafeMath)
                 Source: "SafeMath"
            IndexAccess
               Type: uint256
               Source: "ownerCharacterCount[msg.sender]"
              Identifier ownerCharacterCount
                 Type: mapping(address => uint256)
                 Source: "ownerCharacterCount"
              MemberAccess to member sender
                 Type: address payable
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
  FunctionDefinition "createEvent" - public
     Source: "function createEvent(\r\n        uint _characterId,\r\n        string memory _description\r\n        )\r\n        public\r\n    {\r\n        // Add event to array and get id\r\n        uint id = SafeMath.sub(\r\n            events.push(\r\n                Event(\r\n                    _description\r\n                    )\r\n                ),\r\n            1);\r\n\r\n        // Map id of Character to id of Event\r\n        assert(eventToCharacter[id] == uint(0));\r\n        eventToCharacter[id] = _characterId;\r\n        characterEventCount[_characterId] = SafeMath.add(characterEventCount[_characterId], 1);\r\n    }"
    ParameterList
       Source: "(\r\n        uint _characterId,\r\n        string memory _description\r\n        )"
      VariableDeclaration "_characterId"
         Type: uint256
         Source: "uint _characterId"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_description"
         Type: string memory
         Source: "string memory _description"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Source: ""
    Block
       Source: "{\r\n        // Add event to array and get id\r\n        uint id = SafeMath.sub(\r\n            events.push(\r\n                Event(\r\n                    _description\r\n                    )\r\n                ),\r\n            1);\r\n\r\n        // Map id of Character to id of Event\r\n        assert(eventToCharacter[id] == uint(0));\r\n        eventToCharacter[id] = _characterId;\r\n        characterEventCount[_characterId] = SafeMath.add(characterEventCount[_characterId], 1);\r\n    }"
      VariableDeclarationStatement
         Source: "uint id = SafeMath.sub(\r\n            events.push(\r\n                Event(\r\n                    _description\r\n                    )\r\n                ),\r\n            1)"
        VariableDeclaration "id"
           Type: uint256
           Source: "uint id"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "SafeMath.sub(\r\n            events.push(\r\n                Event(\r\n                    _description\r\n                    )\r\n                ),\r\n            1)"
          MemberAccess to member sub
             Type: function (uint256,uint256) pure returns (uint256)
             Source: "SafeMath.sub"
            Identifier SafeMath
               Type: type(library SafeMath)
               Source: "SafeMath"
          FunctionCall
             Type: uint256
             Source: "events.push(\r\n                Event(\r\n                    _description\r\n                    )\r\n                )"
            MemberAccess to member push
               Type: function (struct CryptoCharacter.Event storage ref) returns (uint256)
               Source: "events.push"
              Identifier events
                 Type: struct CryptoCharacter.Event storage ref[] storage ref
                 Source: "events"
            FunctionCall
               Type: struct CryptoCharacter.Event memory
               Source: "Event(\r\n                    _description\r\n                    )"
              Identifier Event
                 Type: type(struct CryptoCharacter.Event storage pointer)
                 Source: "Event"
              Identifier _description
                 Type: string memory
                 Source: "_description"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ExpressionStatement
         Source: "assert(eventToCharacter[id] == uint(0))"
        FunctionCall
           Type: tuple()
           Source: "assert(eventToCharacter[id] == uint(0))"
          Identifier assert
             Type: function (bool) pure
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "eventToCharacter[id] == uint(0)"
            IndexAccess
               Type: uint256
               Source: "eventToCharacter[id]"
              Identifier eventToCharacter
                 Type: mapping(uint256 => uint256)
                 Source: "eventToCharacter"
              Identifier id
                 Type: uint256
                 Source: "id"
            FunctionCall
               Type: uint256
               Source: "uint(0)"
              ElementaryTypeNameExpression uint
                 Type: type(uint256)
                 Source: "uint"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Source: "eventToCharacter[id] = _characterId"
        Assignment using operator =
           Type: uint256
           Source: "eventToCharacter[id] = _characterId"
          IndexAccess
             Type: uint256
             Source: "eventToCharacter[id]"
            Identifier eventToCharacter
               Type: mapping(uint256 => uint256)
               Source: "eventToCharacter"
            Identifier id
               Type: uint256
               Source: "id"
          Identifier _characterId
             Type: uint256
             Source: "_characterId"
      ExpressionStatement
         Source: "characterEventCount[_characterId] = SafeMath.add(characterEventCount[_characterId], 1)"
        Assignment using operator =
           Type: uint256
           Source: "characterEventCount[_characterId] = SafeMath.add(characterEventCount[_characterId], 1)"
          IndexAccess
             Type: uint256
             Source: "characterEventCount[_characterId]"
            Identifier characterEventCount
               Type: mapping(uint256 => uint256)
               Source: "characterEventCount"
            Identifier _characterId
               Type: uint256
               Source: "_characterId"
          FunctionCall
             Type: uint256
             Source: "SafeMath.add(characterEventCount[_characterId], 1)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "SafeMath.add"
              Identifier SafeMath
                 Type: type(library SafeMath)
                 Source: "SafeMath"
            IndexAccess
               Type: uint256
               Source: "characterEventCount[_characterId]"
              Identifier characterEventCount
                 Type: mapping(uint256 => uint256)
                 Source: "characterEventCount"
              Identifier _characterId
                 Type: uint256
                 Source: "_characterId"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
  FunctionDefinition "createRandomCharacter" - public
     Source: "function createRandomCharacter(\r\n        string memory _identifier,\r\n        string memory _name,\r\n        string memory _unit,\r\n        string memory _race\r\n        )\r\n        public\r\n    {\r\n        uint randDna = generateRandomDna(_identifier, msg.sender);\r\n        _createCharacter(\r\n            _identifier,\r\n            _name,\r\n            _unit,\r\n            _race,\r\n            randDna\r\n            );\r\n    }"
    ParameterList
       Source: "(\r\n        string memory _identifier,\r\n        string memory _name,\r\n        string memory _unit,\r\n        string memory _race\r\n        )"
      VariableDeclaration "_identifier"
         Type: string memory
         Source: "string memory _identifier"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_name"
         Type: string memory
         Source: "string memory _name"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_unit"
         Type: string memory
         Source: "string memory _unit"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_race"
         Type: string memory
         Source: "string memory _race"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Source: ""
    Block
       Source: "{\r\n        uint randDna = generateRandomDna(_identifier, msg.sender);\r\n        _createCharacter(\r\n            _identifier,\r\n            _name,\r\n            _unit,\r\n            _race,\r\n            randDna\r\n            );\r\n    }"
      VariableDeclarationStatement
         Source: "uint randDna = generateRandomDna(_identifier, msg.sender)"
        VariableDeclaration "randDna"
           Type: uint256
           Source: "uint randDna"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "generateRandomDna(_identifier, msg.sender)"
          Identifier generateRandomDna
             Type: function (string memory,address) pure returns (uint256)
             Source: "generateRandomDna"
          Identifier _identifier
             Type: string memory
             Source: "_identifier"
          MemberAccess to member sender
             Type: address payable
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Source: "_createCharacter(\r\n            _identifier,\r\n            _name,\r\n            _unit,\r\n            _race,\r\n            randDna\r\n            )"
        FunctionCall
           Type: tuple()
           Source: "_createCharacter(\r\n            _identifier,\r\n            _name,\r\n            _unit,\r\n            _race,\r\n            randDna\r\n            )"
          Identifier _createCharacter
             Type: function (string memory,string memory,string memory,string memory,uint256)
             Source: "_createCharacter"
          Identifier _identifier
             Type: string memory
             Source: "_identifier"
          Identifier _name
             Type: string memory
             Source: "_name"
          Identifier _unit
             Type: string memory
             Source: "_unit"
          Identifier _race
             Type: string memory
             Source: "_race"
          Identifier randDna
             Type: uint256
             Source: "randDna"
  FunctionDefinition "generateRandomDna" - public
     Source: "function generateRandomDna(string memory _str, address _owner)\r\n        public\r\n        pure\r\n        returns(uint)\r\n    {\r\n        // Generate random uint from string (identifier) + address (owner)\r\n        uint rand = uint(keccak256(abi.encodePacked(_str))) + uint(_owner);\r\n        rand = rand % dnaModulus;\r\n        return rand;\r\n    }"
    ParameterList
       Source: "(string memory _str, address _owner)"
      VariableDeclaration "_str"
         Type: string memory
         Source: "string memory _str"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        // Generate random uint from string (identifier) + address (owner)\r\n        uint rand = uint(keccak256(abi.encodePacked(_str))) + uint(_owner);\r\n        rand = rand % dnaModulus;\r\n        return rand;\r\n    }"
      VariableDeclarationStatement
         Source: "uint rand = uint(keccak256(abi.encodePacked(_str))) + uint(_owner)"
        VariableDeclaration "rand"
           Type: uint256
           Source: "uint rand"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator +
           Type: uint256
           Source: "uint(keccak256(abi.encodePacked(_str))) + uint(_owner)"
          FunctionCall
             Type: uint256
             Source: "uint(keccak256(abi.encodePacked(_str)))"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            FunctionCall
               Type: bytes32
               Source: "keccak256(abi.encodePacked(_str))"
              Identifier keccak256
                 Type: function (bytes memory) pure returns (bytes32)
                 Source: "keccak256"
              FunctionCall
                 Type: bytes memory
                 Source: "abi.encodePacked(_str)"
                MemberAccess to member encodePacked
                   Type: function () pure returns (bytes memory)
                   Source: "abi.encodePacked"
                  Identifier abi
                     Type: abi
                     Source: "abi"
                Identifier _str
                   Type: string memory
                   Source: "_str"
          FunctionCall
             Type: uint256
             Source: "uint(_owner)"
            ElementaryTypeNameExpression uint
               Type: type(uint256)
               Source: "uint"
            Identifier _owner
               Type: address
               Source: "_owner"
      ExpressionStatement
         Source: "rand = rand % dnaModulus"
        Assignment using operator =
           Type: uint256
           Source: "rand = rand % dnaModulus"
          Identifier rand
             Type: uint256
             Source: "rand"
          BinaryOperation using operator %
             Type: uint256
             Source: "rand % dnaModulus"
            Identifier rand
               Type: uint256
               Source: "rand"
            Identifier dnaModulus
               Type: uint256
               Source: "dnaModulus"
      Return
         Source: "return rand"
        Identifier rand
           Type: uint256
           Source: "rand"
  FunctionDefinition "getCharactersByOwner" - public - const
     Source: "function getCharactersByOwner(address _owner)\r\n        public\r\n        view\r\n        returns(uint[] memory)\r\n    {\r\n        uint[] memory result = new uint[](ownerCharacterCount[_owner]);\r\n        uint counter = 0;\r\n        for (uint i = 0; i < characters.length; i++) {\r\n            if (characterToOwner[i] == _owner) {\r\n                result[counter] = i;\r\n                counter++;\r\n            }\r\n        }\r\n        return result;\r\n    }"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint[] memory)"
      VariableDeclaration ""
         Type: uint256[] memory
         Source: "uint[] memory"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    Block
       Source: "{\r\n        uint[] memory result = new uint[](ownerCharacterCount[_owner]);\r\n        uint counter = 0;\r\n        for (uint i = 0; i < characters.length; i++) {\r\n            if (characterToOwner[i] == _owner) {\r\n                result[counter] = i;\r\n                counter++;\r\n            }\r\n        }\r\n        return result;\r\n    }"
      VariableDeclarationStatement
         Source: "uint[] memory result = new uint[](ownerCharacterCount[_owner])"
        VariableDeclaration "result"
           Type: uint256[] memory
           Source: "uint[] memory result"
          ArrayTypeName
             Source: "uint[]"
            ElementaryTypeName uint
               Source: "uint"
        FunctionCall
           Type: uint256[] memory
           Source: "new uint[](ownerCharacterCount[_owner])"
          NewExpression
             Type: function (uint256) pure returns (uint256[] memory)
             Source: "new uint[]"
            ArrayTypeName
               Source: "uint[]"
              ElementaryTypeName uint
                 Source: "uint"
          IndexAccess
             Type: uint256
             Source: "ownerCharacterCount[_owner]"
            Identifier ownerCharacterCount
               Type: mapping(address => uint256)
               Source: "ownerCharacterCount"
            Identifier _owner
               Type: address
               Source: "_owner"
      VariableDeclarationStatement
         Source: "uint counter = 0"
        VariableDeclaration "counter"
           Type: uint256
           Source: "uint counter"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      ForStatement
         Source: "for (uint i = 0; i < characters.length; i++) {\r\n            if (characterToOwner[i] == _owner) {\r\n                result[counter] = i;\r\n                counter++;\r\n            }\r\n        }"
        VariableDeclarationStatement
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Source: "i < characters.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "characters.length"
            Identifier characters
               Type: struct CryptoCharacter.Character storage ref[] storage ref
               Source: "characters"
        ExpressionStatement
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if (characterToOwner[i] == _owner) {\r\n                result[counter] = i;\r\n                counter++;\r\n            }\r\n        }"
          IfStatement
             Source: "if (characterToOwner[i] == _owner) {\r\n                result[counter] = i;\r\n                counter++;\r\n            }"
            BinaryOperation using operator ==
               Type: bool
               Source: "characterToOwner[i] == _owner"
              IndexAccess
                 Type: address
                 Source: "characterToOwner[i]"
                Identifier characterToOwner
                   Type: mapping(uint256 => address)
                   Source: "characterToOwner"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier _owner
                 Type: address
                 Source: "_owner"
            Block
               Source: "{\r\n                result[counter] = i;\r\n                counter++;\r\n            }"
              ExpressionStatement
                 Source: "result[counter] = i"
                Assignment using operator =
                   Type: uint256
                   Source: "result[counter] = i"
                  IndexAccess
                     Type: uint256
                     Source: "result[counter]"
                    Identifier result
                       Type: uint256[] memory
                       Source: "result"
                    Identifier counter
                       Type: uint256
                       Source: "counter"
                  Identifier i
                     Type: uint256
                     Source: "i"
              ExpressionStatement
                 Source: "counter++"
                UnaryOperation (postfix) ++
                   Type: uint256
                   Source: "counter++"
                  Identifier counter
                     Type: uint256
                     Source: "counter"
      Return
         Source: "return result"
        Identifier result
           Type: uint256[] memory
           Source: "result"
  FunctionDefinition "getEventsByCharacter" - public - const
     Source: "function getEventsByCharacter(uint _characterId)\r\n        public\r\n        view\r\n        returns(uint[] memory)\r\n    {\r\n        uint[] memory result = new uint[](characterEventCount[_characterId]);\r\n        uint counter = 0;\r\n        for (uint i = 0; i < events.length; i++) {\r\n            result[counter] = i;\r\n            counter++;\r\n        }\r\n        return result;\r\n    }"
    ParameterList
       Source: "(uint _characterId)"
      VariableDeclaration "_characterId"
         Type: uint256
         Source: "uint _characterId"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(uint[] memory)"
      VariableDeclaration ""
         Type: uint256[] memory
         Source: "uint[] memory"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    Block
       Source: "{\r\n        uint[] memory result = new uint[](characterEventCount[_characterId]);\r\n        uint counter = 0;\r\n        for (uint i = 0; i < events.length; i++) {\r\n            result[counter] = i;\r\n            counter++;\r\n        }\r\n        return result;\r\n    }"
      VariableDeclarationStatement
         Source: "uint[] memory result = new uint[](characterEventCount[_characterId])"
        VariableDeclaration "result"
           Type: uint256[] memory
           Source: "uint[] memory result"
          ArrayTypeName
             Source: "uint[]"
            ElementaryTypeName uint
               Source: "uint"
        FunctionCall
           Type: uint256[] memory
           Source: "new uint[](characterEventCount[_characterId])"
          NewExpression
             Type: function (uint256) pure returns (uint256[] memory)
             Source: "new uint[]"
            ArrayTypeName
               Source: "uint[]"
              ElementaryTypeName uint
                 Source: "uint"
          IndexAccess
             Type: uint256
             Source: "characterEventCount[_characterId]"
            Identifier characterEventCount
               Type: mapping(uint256 => uint256)
               Source: "characterEventCount"
            Identifier _characterId
               Type: uint256
               Source: "_characterId"
      VariableDeclarationStatement
         Source: "uint counter = 0"
        VariableDeclaration "counter"
           Type: uint256
           Source: "uint counter"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      ForStatement
         Source: "for (uint i = 0; i < events.length; i++) {\r\n            result[counter] = i;\r\n            counter++;\r\n        }"
        VariableDeclarationStatement
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Source: "i < events.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "events.length"
            Identifier events
               Type: struct CryptoCharacter.Event storage ref[] storage ref
               Source: "events"
        ExpressionStatement
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            result[counter] = i;\r\n            counter++;\r\n        }"
          ExpressionStatement
             Source: "result[counter] = i"
            Assignment using operator =
               Type: uint256
               Source: "result[counter] = i"
              IndexAccess
                 Type: uint256
                 Source: "result[counter]"
                Identifier result
                   Type: uint256[] memory
                   Source: "result"
                Identifier counter
                   Type: uint256
                   Source: "counter"
              Identifier i
                 Type: uint256
                 Source: "i"
          ExpressionStatement
             Source: "counter++"
            UnaryOperation (postfix) ++
               Type: uint256
               Source: "counter++"
              Identifier counter
                 Type: uint256
                 Source: "counter"
      Return
         Source: "return result"
        Identifier result
           Type: uint256[] memory
           Source: "result"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _characterId)\r\n        public\r\n    {\r\n        require(_from != address(0) && _to != address(0));\r\n        require(_exists(_characterId));\r\n        require(_from != _to);\r\n        require(_isApprovedOrOwner(msg.sender, _characterId));\r\n        ownerCharacterCount[_to] = SafeMath.add(ownerCharacterCount[_to], 1);\r\n        ownerCharacterCount[_from] = SafeMath.sub(ownerCharacterCount[_from], 1);\r\n        characterToOwner[_characterId] = _to;\r\n        emit Transfer(_from, _to, _characterId);\r\n        _clearApproval(_to, _characterId);\r\n    }"
    ParameterList
       Source: "(address _from, address _to, uint256 _characterId)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_characterId"
         Type: uint256
         Source: "uint256 _characterId"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
    Block
       Source: "{\r\n        require(_from != address(0) && _to != address(0));\r\n        require(_exists(_characterId));\r\n        require(_from != _to);\r\n        require(_isApprovedOrOwner(msg.sender, _characterId));\r\n        ownerCharacterCount[_to] = SafeMath.add(ownerCharacterCount[_to], 1);\r\n        ownerCharacterCount[_from] = SafeMath.sub(ownerCharacterCount[_from], 1);\r\n        characterToOwner[_characterId] = _to;\r\n        emit Transfer(_from, _to, _characterId);\r\n        _clearApproval(_to, _characterId);\r\n    }"
      ExpressionStatement
         Source: "require(_from != address(0) && _to != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(_from != address(0) && _to != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "_from != address(0) && _to != address(0)"
            BinaryOperation using operator !=
               Type: bool
               Source: "_from != address(0)"
              Identifier _from
                 Type: address
                 Source: "_from"
              FunctionCall
                 Type: address payable
                 Source: "address(0)"
                ElementaryTypeNameExpression address
                   Type: type(address)
                   Source: "address"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            BinaryOperation using operator !=
               Type: bool
               Source: "_to != address(0)"
              Identifier _to
                 Type: address
                 Source: "_to"
              FunctionCall
                 Type: address payable
                 Source: "address(0)"
                ElementaryTypeNameExpression address
                   Type: type(address)
                   Source: "address"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
      ExpressionStatement
         Source: "require(_exists(_characterId))"
        FunctionCall
           Type: tuple()
           Source: "require(_exists(_characterId))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "_exists(_characterId)"
            Identifier _exists
               Type: function (uint256) view returns (bool)
               Source: "_exists"
            Identifier _characterId
               Type: uint256
               Source: "_characterId"
      ExpressionStatement
         Source: "require(_from != _to)"
        FunctionCall
           Type: tuple()
           Source: "require(_from != _to)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_from != _to"
            Identifier _from
               Type: address
               Source: "_from"
            Identifier _to
               Type: address
               Source: "_to"
      ExpressionStatement
         Source: "require(_isApprovedOrOwner(msg.sender, _characterId))"
        FunctionCall
           Type: tuple()
           Source: "require(_isApprovedOrOwner(msg.sender, _characterId))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "_isApprovedOrOwner(msg.sender, _characterId)"
            Identifier _isApprovedOrOwner
               Type: function (address,uint256) view returns (bool)
               Source: "_isApprovedOrOwner"
            MemberAccess to member sender
               Type: address payable
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier _characterId
               Type: uint256
               Source: "_characterId"
      ExpressionStatement
         Source: "ownerCharacterCount[_to] = SafeMath.add(ownerCharacterCount[_to], 1)"
        Assignment using operator =
           Type: uint256
           Source: "ownerCharacterCount[_to] = SafeMath.add(ownerCharacterCount[_to], 1)"
          IndexAccess
             Type: uint256
             Source: "ownerCharacterCount[_to]"
            Identifier ownerCharacterCount
               Type: mapping(address => uint256)
               Source: "ownerCharacterCount"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "SafeMath.add(ownerCharacterCount[_to], 1)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "SafeMath.add"
              Identifier SafeMath
                 Type: type(library SafeMath)
                 Source: "SafeMath"
            IndexAccess
               Type: uint256
               Source: "ownerCharacterCount[_to]"
              Identifier ownerCharacterCount
                 Type: mapping(address => uint256)
                 Source: "ownerCharacterCount"
              Identifier _to
                 Type: address
                 Source: "_to"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Source: "ownerCharacterCount[_from] = SafeMath.sub(ownerCharacterCount[_from], 1)"
        Assignment using operator =
           Type: uint256
           Source: "ownerCharacterCount[_from] = SafeMath.sub(ownerCharacterCount[_from], 1)"
          IndexAccess
             Type: uint256
             Source: "ownerCharacterCount[_from]"
            Identifier ownerCharacterCount
               Type: mapping(address => uint256)
               Source: "ownerCharacterCount"
            Identifier _from
               Type: address
               Source: "_from"
          FunctionCall
             Type: uint256
             Source: "SafeMath.sub(ownerCharacterCount[_from], 1)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "SafeMath.sub"
              Identifier SafeMath
                 Type: type(library SafeMath)
                 Source: "SafeMath"
            IndexAccess
               Type: uint256
               Source: "ownerCharacterCount[_from]"
              Identifier ownerCharacterCount
                 Type: mapping(address => uint256)
                 Source: "ownerCharacterCount"
              Identifier _from
                 Type: address
                 Source: "_from"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Source: "characterToOwner[_characterId] = _to"
        Assignment using operator =
           Type: address
           Source: "characterToOwner[_characterId] = _to"
          IndexAccess
             Type: address
             Source: "characterToOwner[_characterId]"
            Identifier characterToOwner
               Type: mapping(uint256 => address)
               Source: "characterToOwner"
            Identifier _characterId
               Type: uint256
               Source: "_characterId"
          Identifier _to
             Type: address
             Source: "_to"
      EmitStatement
         Source: "emit Transfer(_from, _to, _characterId)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _characterId)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _characterId
             Type: uint256
             Source: "_characterId"
      ExpressionStatement
         Source: "_clearApproval(_to, _characterId)"
        FunctionCall
           Type: tuple()
           Source: "_clearApproval(_to, _characterId)"
          Identifier _clearApproval
             Type: function (address,uint256)
             Source: "_clearApproval"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _characterId
             Type: uint256
             Source: "_characterId"
  FunctionDefinition "safeTransferFrom" - public
     Source: "function safeTransferFrom(address from, address to, uint256 characterId)\r\n        public\r\n    {\r\n        // solium-disable-next-line arg-overflow\r\n        this.safeTransferFrom(from, to, characterId, \"\");\r\n    }"
    ParameterList
       Source: "(address from, address to, uint256 characterId)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "characterId"
         Type: uint256
         Source: "uint256 characterId"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
    Block
       Source: "{\r\n        // solium-disable-next-line arg-overflow\r\n        this.safeTransferFrom(from, to, characterId, \"\");\r\n    }"
      ExpressionStatement
         Source: "this.safeTransferFrom(from, to, characterId, \"\")"
        FunctionCall
           Type: tuple()
           Source: "this.safeTransferFrom(from, to, characterId, \"\")"
          MemberAccess to member safeTransferFrom
             Type: function (address,address,uint256,bytes memory) external
             Source: "this.safeTransferFrom"
            Identifier this
               Type: contract CryptoCharacter
               Source: "this"
          Identifier from
             Type: address
             Source: "from"
          Identifier to
             Type: address
             Source: "to"
          Identifier characterId
             Type: uint256
             Source: "characterId"
          Literal, token: [no token] value: 
             Type: literal_string ""
             Source: "\"\""
  FunctionDefinition "safeTransferFrom" - public
     Source: "function safeTransferFrom(address from, address to, uint256 characterId, bytes memory _data)\r\n        public\r\n    {\r\n        this.transferFrom(from, to, characterId);\r\n        // solium-disable-next-line arg-overflow\r\n        require(_checkOnERC721Received(from, to, characterId, _data));\r\n    }"
    ParameterList
       Source: "(address from, address to, uint256 characterId, bytes memory _data)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "characterId"
         Type: uint256
         Source: "uint256 characterId"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes memory _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: ""
    Block
       Source: "{\r\n        this.transferFrom(from, to, characterId);\r\n        // solium-disable-next-line arg-overflow\r\n        require(_checkOnERC721Received(from, to, characterId, _data));\r\n    }"
      ExpressionStatement
         Source: "this.transferFrom(from, to, characterId)"
        FunctionCall
           Type: tuple()
           Source: "this.transferFrom(from, to, characterId)"
          MemberAccess to member transferFrom
             Type: function (address,address,uint256) external
             Source: "this.transferFrom"
            Identifier this
               Type: contract CryptoCharacter
               Source: "this"
          Identifier from
             Type: address
             Source: "from"
          Identifier to
             Type: address
             Source: "to"
          Identifier characterId
             Type: uint256
             Source: "characterId"
      ExpressionStatement
         Source: "require(_checkOnERC721Received(from, to, characterId, _data))"
        FunctionCall
           Type: tuple()
           Source: "require(_checkOnERC721Received(from, to, characterId, _data))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "_checkOnERC721Received(from, to, characterId, _data)"
            Identifier _checkOnERC721Received
               Type: function (address,address,uint256,bytes memory) returns (bool)
               Source: "_checkOnERC721Received"
            Identifier from
               Type: address
               Source: "from"
            Identifier to
               Type: address
               Source: "to"
            Identifier characterId
               Type: uint256
               Source: "characterId"
            Identifier _data
               Type: bytes memory
               Source: "_data"
  FunctionDefinition "_checkOnERC721Received"
     Source: "function _checkOnERC721Received(address from, address to, uint256 characterId, bytes memory _data)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        if (!isContract(to)) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, characterId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }"
    ParameterList
       Source: "(address from, address to, uint256 characterId, bytes memory _data)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "characterId"
         Type: uint256
         Source: "uint256 characterId"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes memory _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        if (!isContract(to)) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, characterId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }"
      IfStatement
         Source: "if (!isContract(to)) {\r\n            return true;\r\n        }"
        UnaryOperation (prefix) !
           Type: bool
           Source: "!isContract(to)"
          FunctionCall
             Type: bool
             Source: "isContract(to)"
            Identifier isContract
               Type: function (address) view returns (bool)
               Source: "isContract"
            Identifier to
               Type: address
               Source: "to"
        Block
           Source: "{\r\n            return true;\r\n        }"
          Return
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      VariableDeclarationStatement
         Source: "bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, characterId, _data)"
        VariableDeclaration "retval"
           Type: bytes4
           Source: "bytes4 retval"
          ElementaryTypeName bytes4
             Source: "bytes4"
        FunctionCall
           Type: bytes4
           Source: "IERC721Receiver(to).onERC721Received(msg.sender, from, characterId, _data)"
          MemberAccess to member onERC721Received
             Type: function (address,address,uint256,bytes memory) external returns (bytes4)
             Source: "IERC721Receiver(to).onERC721Received"
            FunctionCall
               Type: contract IERC721Receiver
               Source: "IERC721Receiver(to)"
              Identifier IERC721Receiver
                 Type: type(contract IERC721Receiver)
                 Source: "IERC721Receiver"
              Identifier to
                 Type: address
                 Source: "to"
          MemberAccess to member sender
             Type: address payable
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier from
             Type: address
             Source: "from"
          Identifier characterId
             Type: uint256
             Source: "characterId"
          Identifier _data
             Type: bytes memory
             Source: "_data"
      Return
         Source: "return (retval == _ERC721_RECEIVED)"
        TupleExpression
           Type: bool
           Source: "(retval == _ERC721_RECEIVED)"
          BinaryOperation using operator ==
             Type: bool
             Source: "retval == _ERC721_RECEIVED"
            Identifier retval
               Type: bytes4
               Source: "retval"
            Identifier _ERC721_RECEIVED
               Type: bytes4
               Source: "_ERC721_RECEIVED"
  FunctionDefinition "burn" - public
     Source: "function burn(uint256 _characterId)\r\n        external\r\n    {\r\n        require(msg.sender != address(0));\r\n        require(_exists(_characterId));\r\n        require(_isApprovedOrOwner(msg.sender, _characterId));\r\n\r\n        ownerCharacterCount[msg.sender] = SafeMath.sub(ownerCharacterCount[msg.sender], 1);\r\n        characterToOwner[_characterId] = address(0);\r\n    }"
    ParameterList
       Source: "(uint256 _characterId)"
      VariableDeclaration "_characterId"
         Type: uint256
         Source: "uint256 _characterId"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
    Block
       Source: "{\r\n        require(msg.sender != address(0));\r\n        require(_exists(_characterId));\r\n        require(_isApprovedOrOwner(msg.sender, _characterId));\r\n\r\n        ownerCharacterCount[msg.sender] = SafeMath.sub(ownerCharacterCount[msg.sender], 1);\r\n        characterToOwner[_characterId] = address(0);\r\n    }"
      ExpressionStatement
         Source: "require(msg.sender != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "msg.sender != address(0)"
            MemberAccess to member sender
               Type: address payable
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            FunctionCall
               Type: address payable
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Source: "require(_exists(_characterId))"
        FunctionCall
           Type: tuple()
           Source: "require(_exists(_characterId))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "_exists(_characterId)"
            Identifier _exists
               Type: function (uint256) view returns (bool)
               Source: "_exists"
            Identifier _characterId
               Type: uint256
               Source: "_characterId"
      ExpressionStatement
         Source: "require(_isApprovedOrOwner(msg.sender, _characterId))"
        FunctionCall
           Type: tuple()
           Source: "require(_isApprovedOrOwner(msg.sender, _characterId))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "_isApprovedOrOwner(msg.sender, _characterId)"
            Identifier _isApprovedOrOwner
               Type: function (address,uint256) view returns (bool)
               Source: "_isApprovedOrOwner"
            MemberAccess to member sender
               Type: address payable
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier _characterId
               Type: uint256
               Source: "_characterId"
      ExpressionStatement
         Source: "ownerCharacterCount[msg.sender] = SafeMath.sub(ownerCharacterCount[msg.sender], 1)"
        Assignment using operator =
           Type: uint256
           Source: "ownerCharacterCount[msg.sender] = SafeMath.sub(ownerCharacterCount[msg.sender], 1)"
          IndexAccess
             Type: uint256
             Source: "ownerCharacterCount[msg.sender]"
            Identifier ownerCharacterCount
               Type: mapping(address => uint256)
               Source: "ownerCharacterCount"
            MemberAccess to member sender
               Type: address payable
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "SafeMath.sub(ownerCharacterCount[msg.sender], 1)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "SafeMath.sub"
              Identifier SafeMath
                 Type: type(library SafeMath)
                 Source: "SafeMath"
            IndexAccess
               Type: uint256
               Source: "ownerCharacterCount[msg.sender]"
              Identifier ownerCharacterCount
                 Type: mapping(address => uint256)
                 Source: "ownerCharacterCount"
              MemberAccess to member sender
                 Type: address payable
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Source: "characterToOwner[_characterId] = address(0)"
        Assignment using operator =
           Type: address
           Source: "characterToOwner[_characterId] = address(0)"
          IndexAccess
             Type: address
             Source: "characterToOwner[_characterId]"
            Identifier characterToOwner
               Type: mapping(uint256 => address)
               Source: "characterToOwner"
            Identifier _characterId
               Type: uint256
               Source: "_characterId"
          FunctionCall
             Type: address payable
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner)\r\n        public\r\n        view\r\n        returns(uint256 _balance)\r\n    {\r\n        return ownerCharacterCount[_owner];\r\n    }"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 _balance)"
      VariableDeclaration "_balance"
         Type: uint256
         Source: "uint256 _balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        return ownerCharacterCount[_owner];\r\n    }"
      Return
         Source: "return ownerCharacterCount[_owner]"
        IndexAccess
           Type: uint256
           Source: "ownerCharacterCount[_owner]"
          Identifier ownerCharacterCount
             Type: mapping(address => uint256)
             Source: "ownerCharacterCount"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "ownerOf" - public - const
     Source: "function ownerOf(uint256 _characterId)\r\n        public\r\n        view\r\n        returns(address _owner)\r\n    {\r\n        address owner = characterToOwner[_characterId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }"
    ParameterList
       Source: "(uint256 _characterId)"
      VariableDeclaration "_characterId"
         Type: uint256
         Source: "uint256 _characterId"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        address owner = characterToOwner[_characterId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }"
      VariableDeclarationStatement
         Source: "address owner = characterToOwner[_characterId]"
        VariableDeclaration "owner"
           Type: address
           Source: "address owner"
          ElementaryTypeName address
             Source: "address"
        IndexAccess
           Type: address
           Source: "characterToOwner[_characterId]"
          Identifier characterToOwner
             Type: mapping(uint256 => address)
             Source: "characterToOwner"
          Identifier _characterId
             Type: uint256
             Source: "_characterId"
      ExpressionStatement
         Source: "require(owner != address(0))"
        FunctionCall
           Type: tuple()
           Source: "require(owner != address(0))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "owner != address(0)"
            Identifier owner
               Type: address
               Source: "owner"
            FunctionCall
               Type: address payable
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      Return
         Source: "return owner"
        Identifier owner
           Type: address
           Source: "owner"
  FunctionDefinition "approve" - public
     Source: "function approve(address _to, uint256 _characterId)\r\n        public\r\n    {\r\n        require(msg.sender == characterToOwner[_characterId]);\r\n        characterApprovals[_characterId] = _to;\r\n        emit Approval(msg.sender, _to, _characterId);\r\n    }"
    ParameterList
       Source: "(address _to, uint256 _characterId)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_characterId"
         Type: uint256
         Source: "uint256 _characterId"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
    Block
       Source: "{\r\n        require(msg.sender == characterToOwner[_characterId]);\r\n        characterApprovals[_characterId] = _to;\r\n        emit Approval(msg.sender, _to, _characterId);\r\n    }"
      ExpressionStatement
         Source: "require(msg.sender == characterToOwner[_characterId])"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == characterToOwner[_characterId])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == characterToOwner[_characterId]"
            MemberAccess to member sender
               Type: address payable
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            IndexAccess
               Type: address
               Source: "characterToOwner[_characterId]"
              Identifier characterToOwner
                 Type: mapping(uint256 => address)
                 Source: "characterToOwner"
              Identifier _characterId
                 Type: uint256
                 Source: "_characterId"
      ExpressionStatement
         Source: "characterApprovals[_characterId] = _to"
        Assignment using operator =
           Type: address
           Source: "characterApprovals[_characterId] = _to"
          IndexAccess
             Type: address
             Source: "characterApprovals[_characterId]"
            Identifier characterApprovals
               Type: mapping(uint256 => address)
               Source: "characterApprovals"
            Identifier _characterId
               Type: uint256
               Source: "_characterId"
          Identifier _to
             Type: address
             Source: "_to"
      EmitStatement
         Source: "emit Approval(msg.sender, _to, _characterId)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _to, _characterId)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address payable
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _characterId
             Type: uint256
             Source: "_characterId"
  FunctionDefinition "getApproved" - public - const
     Source: "function getApproved(uint256 characterId)\r\n        public\r\n        view\r\n        returns(address operator)\r\n    {\r\n        require(_exists(characterId));\r\n        return characterApprovals[characterId];\r\n    }"
    ParameterList
       Source: "(uint256 characterId)"
      VariableDeclaration "characterId"
         Type: uint256
         Source: "uint256 characterId"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(address operator)"
      VariableDeclaration "operator"
         Type: address
         Source: "address operator"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\r\n        require(_exists(characterId));\r\n        return characterApprovals[characterId];\r\n    }"
      ExpressionStatement
         Source: "require(_exists(characterId))"
        FunctionCall
           Type: tuple()
           Source: "require(_exists(characterId))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "_exists(characterId)"
            Identifier _exists
               Type: function (uint256) view returns (bool)
               Source: "_exists"
            Identifier characterId
               Type: uint256
               Source: "characterId"
      Return
         Source: "return characterApprovals[characterId]"
        IndexAccess
           Type: address
           Source: "characterApprovals[characterId]"
          Identifier characterApprovals
             Type: mapping(uint256 => address)
             Source: "characterApprovals"
          Identifier characterId
             Type: uint256
             Source: "characterId"
  FunctionDefinition "_clearApproval"
     Source: "function _clearApproval(address owner, uint256 characterId) private {\r\n        require(characterToOwner[characterId] == owner);\r\n        require(_exists(characterId));\r\n        if (characterApprovals[characterId] != address(0)) {\r\n            characterApprovals[characterId] = address(0);\r\n        }\r\n    }"
    ParameterList
       Source: "(address owner, uint256 characterId)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "characterId"
         Type: uint256
         Source: "uint256 characterId"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
    Block
       Source: "{\r\n        require(characterToOwner[characterId] == owner);\r\n        require(_exists(characterId));\r\n        if (characterApprovals[characterId] != address(0)) {\r\n            characterApprovals[characterId] = address(0);\r\n        }\r\n    }"
      ExpressionStatement
         Source: "require(characterToOwner[characterId] == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(characterToOwner[characterId] == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "characterToOwner[characterId] == owner"
            IndexAccess
               Type: address
               Source: "characterToOwner[characterId]"
              Identifier characterToOwner
                 Type: mapping(uint256 => address)
                 Source: "characterToOwner"
              Identifier characterId
                 Type: uint256
                 Source: "characterId"
            Identifier owner
               Type: address
               Source: "owner"
      ExpressionStatement
         Source: "require(_exists(characterId))"
        FunctionCall
           Type: tuple()
           Source: "require(_exists(characterId))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "_exists(characterId)"
            Identifier _exists
               Type: function (uint256) view returns (bool)
               Source: "_exists"
            Identifier characterId
               Type: uint256
               Source: "characterId"
      IfStatement
         Source: "if (characterApprovals[characterId] != address(0)) {\r\n            characterApprovals[characterId] = address(0);\r\n        }"
        BinaryOperation using operator !=
           Type: bool
           Source: "characterApprovals[characterId] != address(0)"
          IndexAccess
             Type: address
             Source: "characterApprovals[characterId]"
            Identifier characterApprovals
               Type: mapping(uint256 => address)
               Source: "characterApprovals"
            Identifier characterId
               Type: uint256
               Source: "characterId"
          FunctionCall
             Type: address payable
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            characterApprovals[characterId] = address(0);\r\n        }"
          ExpressionStatement
             Source: "characterApprovals[characterId] = address(0)"
            Assignment using operator =
               Type: address
               Source: "characterApprovals[characterId] = address(0)"
              IndexAccess
                 Type: address
                 Source: "characterApprovals[characterId]"
                Identifier characterApprovals
                   Type: mapping(uint256 => address)
                   Source: "characterApprovals"
                Identifier characterId
                   Type: uint256
                   Source: "characterId"
              FunctionCall
                 Type: address payable
                 Source: "address(0)"
                ElementaryTypeNameExpression address
                   Type: type(address)
                   Source: "address"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
  FunctionDefinition "setApprovalForAll" - public
     Source: "function setApprovalForAll(address to, bool approved)\r\n        public\r\n    {\r\n        require(to != msg.sender);\r\n        operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }"
    ParameterList
       Source: "(address to, bool approved)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "approved"
         Type: bool
         Source: "bool approved"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Source: ""
    Block
       Source: "{\r\n        require(to != msg.sender);\r\n        operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }"
      ExpressionStatement
         Source: "require(to != msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "require(to != msg.sender)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "to != msg.sender"
            Identifier to
               Type: address
               Source: "to"
            MemberAccess to member sender
               Type: address payable
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      ExpressionStatement
         Source: "operatorApprovals[msg.sender][to] = approved"
        Assignment using operator =
           Type: bool
           Source: "operatorApprovals[msg.sender][to] = approved"
          IndexAccess
             Type: bool
             Source: "operatorApprovals[msg.sender][to]"
            IndexAccess
               Type: mapping(address => bool)
               Source: "operatorApprovals[msg.sender]"
              Identifier operatorApprovals
                 Type: mapping(address => mapping(address => bool))
                 Source: "operatorApprovals"
              MemberAccess to member sender
                 Type: address payable
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier to
               Type: address
               Source: "to"
          Identifier approved
             Type: bool
             Source: "approved"
      EmitStatement
         Source: "emit ApprovalForAll(msg.sender, to, approved)"
        FunctionCall
           Type: tuple()
           Source: "ApprovalForAll(msg.sender, to, approved)"
          Identifier ApprovalForAll
             Type: function (address,address,bool)
             Source: "ApprovalForAll"
          MemberAccess to member sender
             Type: address payable
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier to
             Type: address
             Source: "to"
          Identifier approved
             Type: bool
             Source: "approved"
  FunctionDefinition "isApprovedForAll" - public - const
     Source: "function isApprovedForAll(address owner, address operator)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return operatorApprovals[owner][operator];\r\n    }"
    ParameterList
       Source: "(address owner, address operator)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "operator"
         Type: address
         Source: "address operator"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        return operatorApprovals[owner][operator];\r\n    }"
      Return
         Source: "return operatorApprovals[owner][operator]"
        IndexAccess
           Type: bool
           Source: "operatorApprovals[owner][operator]"
          IndexAccess
             Type: mapping(address => bool)
             Source: "operatorApprovals[owner]"
            Identifier operatorApprovals
               Type: mapping(address => mapping(address => bool))
               Source: "operatorApprovals"
            Identifier owner
               Type: address
               Source: "owner"
          Identifier operator
             Type: address
             Source: "operator"
  FunctionDefinition "takeOwnership" - public
     Source: "function takeOwnership(uint256 _characterId)\r\n        public\r\n    {\r\n        require(_isApprovedOrOwner(msg.sender, _characterId));\r\n        address owner = this.ownerOf(_characterId);\r\n        this.transferFrom(owner, msg.sender, _characterId);\r\n    }"
    ParameterList
       Source: "(uint256 _characterId)"
      VariableDeclaration "_characterId"
         Type: uint256
         Source: "uint256 _characterId"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
    Block
       Source: "{\r\n        require(_isApprovedOrOwner(msg.sender, _characterId));\r\n        address owner = this.ownerOf(_characterId);\r\n        this.transferFrom(owner, msg.sender, _characterId);\r\n    }"
      ExpressionStatement
         Source: "require(_isApprovedOrOwner(msg.sender, _characterId))"
        FunctionCall
           Type: tuple()
           Source: "require(_isApprovedOrOwner(msg.sender, _characterId))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "_isApprovedOrOwner(msg.sender, _characterId)"
            Identifier _isApprovedOrOwner
               Type: function (address,uint256) view returns (bool)
               Source: "_isApprovedOrOwner"
            MemberAccess to member sender
               Type: address payable
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier _characterId
               Type: uint256
               Source: "_characterId"
      VariableDeclarationStatement
         Source: "address owner = this.ownerOf(_characterId)"
        VariableDeclaration "owner"
           Type: address
           Source: "address owner"
          ElementaryTypeName address
             Source: "address"
        FunctionCall
           Type: address
           Source: "this.ownerOf(_characterId)"
          MemberAccess to member ownerOf
             Type: function (uint256) view external returns (address)
             Source: "this.ownerOf"
            Identifier this
               Type: contract CryptoCharacter
               Source: "this"
          Identifier _characterId
             Type: uint256
             Source: "_characterId"
      ExpressionStatement
         Source: "this.transferFrom(owner, msg.sender, _characterId)"
        FunctionCall
           Type: tuple()
           Source: "this.transferFrom(owner, msg.sender, _characterId)"
          MemberAccess to member transferFrom
             Type: function (address,address,uint256) external
             Source: "this.transferFrom"
            Identifier this
               Type: contract CryptoCharacter
               Source: "this"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address payable
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _characterId
             Type: uint256
             Source: "_characterId"
  FunctionDefinition "_exists" - const
     Source: "function _exists(uint256 characterId)\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        address owner = characterToOwner[characterId];\r\n        return owner != address(0);\r\n    }"
    ParameterList
       Source: "(uint256 characterId)"
      VariableDeclaration "characterId"
         Type: uint256
         Source: "uint256 characterId"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        address owner = characterToOwner[characterId];\r\n        return owner != address(0);\r\n    }"
      VariableDeclarationStatement
         Source: "address owner = characterToOwner[characterId]"
        VariableDeclaration "owner"
           Type: address
           Source: "address owner"
          ElementaryTypeName address
             Source: "address"
        IndexAccess
           Type: address
           Source: "characterToOwner[characterId]"
          Identifier characterToOwner
             Type: mapping(uint256 => address)
             Source: "characterToOwner"
          Identifier characterId
             Type: uint256
             Source: "characterId"
      Return
         Source: "return owner != address(0)"
        BinaryOperation using operator !=
           Type: bool
           Source: "owner != address(0)"
          Identifier owner
             Type: address
             Source: "owner"
          FunctionCall
             Type: address payable
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
  FunctionDefinition "_isApprovedOrOwner" - const
     Source: "function _isApprovedOrOwner(address spender, uint256 characterId)\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        address owner = characterToOwner[characterId];\r\n        // Disable solium check because of\r\n        // https://github.com/duaraghav8/Solium/issues/175\r\n        // solium-disable-next-line operator-whitespace\r\n        return (spender == owner || this.getApproved(characterId) == spender || this.isApprovedForAll(owner, spender));\r\n    }"
    ParameterList
       Source: "(address spender, uint256 characterId)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "characterId"
         Type: uint256
         Source: "uint256 characterId"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        address owner = characterToOwner[characterId];\r\n        // Disable solium check because of\r\n        // https://github.com/duaraghav8/Solium/issues/175\r\n        // solium-disable-next-line operator-whitespace\r\n        return (spender == owner || this.getApproved(characterId) == spender || this.isApprovedForAll(owner, spender));\r\n    }"
      VariableDeclarationStatement
         Source: "address owner = characterToOwner[characterId]"
        VariableDeclaration "owner"
           Type: address
           Source: "address owner"
          ElementaryTypeName address
             Source: "address"
        IndexAccess
           Type: address
           Source: "characterToOwner[characterId]"
          Identifier characterToOwner
             Type: mapping(uint256 => address)
             Source: "characterToOwner"
          Identifier characterId
             Type: uint256
             Source: "characterId"
      Return
         Source: "return (spender == owner || this.getApproved(characterId) == spender || this.isApprovedForAll(owner, spender))"
        TupleExpression
           Type: bool
           Source: "(spender == owner || this.getApproved(characterId) == spender || this.isApprovedForAll(owner, spender))"
          BinaryOperation using operator ||
             Type: bool
             Source: "spender == owner || this.getApproved(characterId) == spender || this.isApprovedForAll(owner, spender)"
            BinaryOperation using operator ||
               Type: bool
               Source: "spender == owner || this.getApproved(characterId) == spender"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "spender == owner"
                Identifier spender
                   Type: address
                   Source: "spender"
                Identifier owner
                   Type: address
                   Source: "owner"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "this.getApproved(characterId) == spender"
                FunctionCall
                   Type: address
                   Source: "this.getApproved(characterId)"
                  MemberAccess to member getApproved
                     Type: function (uint256) view external returns (address)
                     Source: "this.getApproved"
                    Identifier this
                       Type: contract CryptoCharacter
                       Source: "this"
                  Identifier characterId
                     Type: uint256
                     Source: "characterId"
                Identifier spender
                   Type: address
                   Source: "spender"
            FunctionCall
               Type: bool
               Source: "this.isApprovedForAll(owner, spender)"
              MemberAccess to member isApprovedForAll
                 Type: function (address,address) view external returns (bool)
                 Source: "this.isApprovedForAll"
                Identifier this
                   Type: contract CryptoCharacter
                   Source: "this"
              Identifier owner
                 Type: address
                 Source: "owner"
              Identifier spender
                 Type: address
                 Source: "spender"
  ModifierDefinition "isUnique"
     Source: "modifier isUnique(string memory _identifier, uint256 _dna) {\r\n        bool result = true;\r\n        for(uint i = 0; i < characters.length; i++) {\r\n            if(keccak256(abi.encodePacked(characters[i].identifier)) == keccak256(abi.encodePacked(_identifier)) && characters[i].dna == _dna) {\r\n                result = false;\r\n            }\r\n        }\r\n        require(result, \"Character with name, unit and race combination already exists.\");\r\n        _;\r\n    }"
    ParameterList
       Source: "(string memory _identifier, uint256 _dna)"
      VariableDeclaration "_identifier"
         Type: string memory
         Source: "string memory _identifier"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_dna"
         Type: uint256
         Source: "uint256 _dna"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n        bool result = true;\r\n        for(uint i = 0; i < characters.length; i++) {\r\n            if(keccak256(abi.encodePacked(characters[i].identifier)) == keccak256(abi.encodePacked(_identifier)) && characters[i].dna == _dna) {\r\n                result = false;\r\n            }\r\n        }\r\n        require(result, \"Character with name, unit and race combination already exists.\");\r\n        _;\r\n    }"
      VariableDeclarationStatement
         Source: "bool result = true"
        VariableDeclaration "result"
           Type: bool
           Source: "bool result"
          ElementaryTypeName bool
             Source: "bool"
        Literal, token: true value: true
           Type: bool
           Source: "true"
      ForStatement
         Source: "for(uint i = 0; i < characters.length; i++) {\r\n            if(keccak256(abi.encodePacked(characters[i].identifier)) == keccak256(abi.encodePacked(_identifier)) && characters[i].dna == _dna) {\r\n                result = false;\r\n            }\r\n        }"
        VariableDeclarationStatement
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Source: "i < characters.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "characters.length"
            Identifier characters
               Type: struct CryptoCharacter.Character storage ref[] storage ref
               Source: "characters"
        ExpressionStatement
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\r\n            if(keccak256(abi.encodePacked(characters[i].identifier)) == keccak256(abi.encodePacked(_identifier)) && characters[i].dna == _dna) {\r\n                result = false;\r\n            }\r\n        }"
          IfStatement
             Source: "if(keccak256(abi.encodePacked(characters[i].identifier)) == keccak256(abi.encodePacked(_identifier)) && characters[i].dna == _dna) {\r\n                result = false;\r\n            }"
            BinaryOperation using operator &&
               Type: bool
               Source: "keccak256(abi.encodePacked(characters[i].identifier)) == keccak256(abi.encodePacked(_identifier)) && characters[i].dna == _dna"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "keccak256(abi.encodePacked(characters[i].identifier)) == keccak256(abi.encodePacked(_identifier))"
                FunctionCall
                   Type: bytes32
                   Source: "keccak256(abi.encodePacked(characters[i].identifier))"
                  Identifier keccak256
                     Type: function (bytes memory) pure returns (bytes32)
                     Source: "keccak256"
                  FunctionCall
                     Type: bytes memory
                     Source: "abi.encodePacked(characters[i].identifier)"
                    MemberAccess to member encodePacked
                       Type: function () pure returns (bytes memory)
                       Source: "abi.encodePacked"
                      Identifier abi
                         Type: abi
                         Source: "abi"
                    MemberAccess to member identifier
                       Type: string storage ref
                       Source: "characters[i].identifier"
                      IndexAccess
                         Type: struct CryptoCharacter.Character storage ref
                         Source: "characters[i]"
                        Identifier characters
                           Type: struct CryptoCharacter.Character storage ref[] storage ref
                           Source: "characters"
                        Identifier i
                           Type: uint256
                           Source: "i"
                FunctionCall
                   Type: bytes32
                   Source: "keccak256(abi.encodePacked(_identifier))"
                  Identifier keccak256
                     Type: function (bytes memory) pure returns (bytes32)
                     Source: "keccak256"
                  FunctionCall
                     Type: bytes memory
                     Source: "abi.encodePacked(_identifier)"
                    MemberAccess to member encodePacked
                       Type: function () pure returns (bytes memory)
                       Source: "abi.encodePacked"
                      Identifier abi
                         Type: abi
                         Source: "abi"
                    Identifier _identifier
                       Type: string memory
                       Source: "_identifier"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "characters[i].dna == _dna"
                MemberAccess to member dna
                   Type: uint256
                   Source: "characters[i].dna"
                  IndexAccess
                     Type: struct CryptoCharacter.Character storage ref
                     Source: "characters[i]"
                    Identifier characters
                       Type: struct CryptoCharacter.Character storage ref[] storage ref
                       Source: "characters"
                    Identifier i
                       Type: uint256
                       Source: "i"
                Identifier _dna
                   Type: uint256
                   Source: "_dna"
            Block
               Source: "{\r\n                result = false;\r\n            }"
              ExpressionStatement
                 Source: "result = false"
                Assignment using operator =
                   Type: bool
                   Source: "result = false"
                  Identifier result
                     Type: bool
                     Source: "result"
                  Literal, token: false value: false
                     Type: bool
                     Source: "false"
      ExpressionStatement
         Source: "require(result, \"Character with name, unit and race combination already exists.\")"
        FunctionCall
           Type: tuple()
           Source: "require(result, \"Character with name, unit and race combination already exists.\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          Identifier result
             Type: bool
             Source: "result"
          Literal, token: [no token] value: Character with name, unit and race combination already exists.
             Type: literal_string "Character with name, unit and race combination already exists."
             Source: "\"Character with name, unit and race combination already exists.\""
      PlaceholderStatement
         Source: "_"
  FunctionDefinition "isContract" - const
     Source: "function isContract(address account)\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }"
    ParameterList
       Source: "(address account)"
      VariableDeclaration "account"
         Type: address
         Source: "address account"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }"
      VariableDeclarationStatement
         Source: "uint256 size"
        VariableDeclaration "size"
           Type: uint256
           Source: "uint256 size"
          ElementaryTypeName uint256
             Source: "uint256"
      InlineAssembly
         Source: "assembly { size := extcodesize(account) }"
      Return
         Source: "return size > 0"
        BinaryOperation using operator >
           Type: bool
           Source: "size > 0"
          Identifier size
             Type: uint256
             Source: "size"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
